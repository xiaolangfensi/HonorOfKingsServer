"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../../utils");
var NodeHandlerHelper_1 = require("./NodeHandlerHelper");
var StraightReplacementNodeHandler_1 = require("./StraightReplacementNodeHandler");
/**
 * Handler for deailing with a node that is going to have a descendant replaced based on the range.
 */
var RangeHandler = /** @class */ (function () {
    // private readonly replacingLength: number | undefined;
    function RangeHandler(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
        // this.replacingLength = opts.replacingLength;
    }
    RangeHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {
        var currentSourceFile = currentNode._sourceFile.compilerNode;
        var hasParsedTokens = currentNode._hasParsedTokens();
        var currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(hasParsedTokens ? currentNode._getCompilerChildren() : currentNode._getCompilerForEachChildren()));
        var newNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(hasParsedTokens ? newNode.getChildren(newSourceFile) : utils_1.getCompilerForEachChildren(newNode)));
        // get the first child
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        // go down into the children if before the node or in a surrounding node
        while (!currentNodeChildren.done && !newNodeChildren.done
            && (currentNodeChildren.peek.getStart(currentSourceFile) < this.start
                || currentNodeChildren.peek.getStart(currentSourceFile) === this.start && newNodeChildren.peek.end > this.end)) {
            this.rangeHandlerReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        }
        // skip over the new children while they're within the range
        while (!newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.end)
            newNodeChildren.next();
        // handle the rest
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        // ensure the new children iterator is done too
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    };
    RangeHandler.prototype.straightReplace = function (currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    };
    RangeHandler.prototype.rangeHandlerReplace = function (currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this, currentNode, nextNode, newSourceFile);
    };
    return RangeHandler;
}());
exports.RangeHandler = RangeHandler;
