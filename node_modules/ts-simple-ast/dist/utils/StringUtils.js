"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors = require("../errors");
var isSpaces = /^ +$/;
var isWhitespace = /^\s$/;
var startsWithNewLine = /^\r?\n/;
var endsWithNewLine = /\r?\n$/;
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    StringUtils.hasBom = function (text) {
        return text.charCodeAt(0) === 0xFEFF;
    };
    StringUtils.stripBom = function (text) {
        if (StringUtils.hasBom(text))
            return text.slice(1);
        return text;
    };
    StringUtils.isNullOrWhitespace = function (str) {
        return typeof str !== "string" || str.trim().length === 0;
    };
    StringUtils.isNullOrEmpty = function (str) {
        return typeof str !== "string" || str.length === 0;
    };
    StringUtils.repeat = function (str, times) {
        var newStr = "";
        for (var i = 0; i < times; i++)
            newStr += str;
        return newStr;
    };
    StringUtils.startsWith = function (str, startsWithString) {
        if (typeof String.prototype.startsWith === "function")
            return str.startsWith(startsWithString);
        return Es5StringUtils.startsWith(str, startsWithString);
    };
    StringUtils.endsWith = function (str, endsWithString) {
        if (typeof String.prototype.endsWith === "function")
            return str.endsWith(endsWithString);
        return Es5StringUtils.endsWith(str, endsWithString);
    };
    StringUtils.startsWithNewLine = function (str) {
        return startsWithNewLine.test(str);
    };
    StringUtils.endsWithNewLine = function (str) {
        return endsWithNewLine.test(str);
    };
    StringUtils.insertAtLastNonWhitespace = function (str, insertText) {
        var i = str.length;
        while (i > 0 && isWhitespace.test(str[i - 1]))
            i--;
        return str.substring(0, i) + insertText + str.substring(i);
    };
    StringUtils.getLineNumberAtPos = function (str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length + 1], "pos");
        // do not allocate a string in this method
        var count = 0;
        for (var i = 0; i < pos; i++) {
            if (str[i] === "\n" || (str[i] === "\r" && str[i + 1] !== "\n"))
                count++;
        }
        return count + 1; // convert count to line number
    };
    StringUtils.getLengthFromLineStartAtPos = function (str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length + 1], "pos");
        var startPos = pos;
        while (pos > 0) {
            var previousChar = str[pos - 1];
            if (previousChar === "\n" || previousChar === "\r")
                break;
            pos--;
        }
        return startPos - pos;
    };
    StringUtils.escapeForWithinString = function (str, quoteKind) {
        return StringUtils.escapeChar(str, quoteKind).replace(/(\r?\n)/g, "\\$1");
    };
    /**
     * Escapes all the occurences of the char in the string.
     */
    StringUtils.escapeChar = function (str, char) {
        if (char.length !== 1)
            throw new errors.InvalidOperationError("Specified char must be one character long.");
        var result = "";
        for (var i = 0; i < str.length; i++) {
            if (str[i] === char)
                result += "\\";
            result += str[i];
        }
        return result;
    };
    StringUtils.indent = function (str, times, indentText, isInStringAtPos) {
        var e_1, _a;
        // todo: unit test this (right now it's somewhat tested indirectly)
        var unindentRegex = times > 0 ? undefined : new RegExp(getDeindentRegexText());
        var newLines = [];
        var pos = 0;
        try {
            for (var _b = tslib_1.__values(str.split("\n")), _c = _b.next(); !_c.done; _c = _b.next()) {
                var line = _c.value;
                if (isInStringAtPos(pos))
                    newLines.push(line);
                else if (times > 0)
                    newLines.push(StringUtils.repeat(indentText, times) + line);
                else // negative
                    newLines.push(line.replace(unindentRegex, ""));
                pos += line.length + 1; // +1 for \n char
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newLines.join("\n");
        function getDeindentRegexText() {
            var text = "^";
            for (var i = 0; i < Math.abs(times); i++) {
                text += "(";
                if (isSpaces.test(indentText)) {
                    // the optional string makes it possible to unindent when a line doesn't have the full number of spaces
                    for (var j = 0; j < indentText.length; j++)
                        text += " ?";
                }
                else
                    text += indentText;
                text += "|\t)?";
            }
            return text;
        }
    };
    return StringUtils;
}());
exports.StringUtils = StringUtils;
var Es5StringUtils = /** @class */ (function () {
    function Es5StringUtils() {
    }
    Es5StringUtils.startsWith = function (str, startsWithString) {
        // todo: don't allocate a string
        return str.substr(0, startsWithString.length) === startsWithString;
    };
    Es5StringUtils.endsWith = function (str, endsWithString) {
        // todo: don't allocate a string
        return str.substr(str.length - endsWithString.length, endsWithString.length) === endsWithString;
    };
    return Es5StringUtils;
}());
exports.Es5StringUtils = Es5StringUtils;
