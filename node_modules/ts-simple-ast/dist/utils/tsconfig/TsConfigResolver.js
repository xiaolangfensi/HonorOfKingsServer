"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var compiler_1 = require("../../compiler");
var typescript_1 = require("../../typescript");
var utils_1 = require("../../utils");
var getTsParseConfigHost_1 = require("./getTsParseConfigHost");
var TsConfigResolver = /** @class */ (function () {
    function TsConfigResolver(fileSystem, tsConfigFilePath, encoding) {
        this.fileSystem = fileSystem;
        this.encoding = encoding;
        this.host = getTsParseConfigHost_1.getTsParseConfigHost(fileSystem, { encoding: encoding });
        this.tsConfigFilePath = fileSystem.getStandardizedAbsolutePath(tsConfigFilePath);
        this.tsConfigDirPath = utils_1.FileUtils.getDirPath(this.tsConfigFilePath);
    }
    TsConfigResolver.prototype.getCompilerOptions = function () {
        return this.parseJsonConfigFileContent().options;
    };
    TsConfigResolver.prototype.getErrors = function () {
        return (this.parseJsonConfigFileContent().errors || []).map(function (e) { return new compiler_1.Diagnostic(undefined, e); });
    };
    TsConfigResolver.prototype.getPaths = function (compilerOptions) {
        var e_1, _a, e_2, _b, e_3, _c;
        var files = utils_1.createHashSet();
        var _d = this, tsConfigDirPath = _d.tsConfigDirPath, fileSystem = _d.fileSystem;
        var directories = utils_1.createHashSet();
        compilerOptions = compilerOptions || this.getCompilerOptions();
        var rootDirs = getRootDirs(compilerOptions);
        var configFileContent = this.parseJsonConfigFileContent();
        try {
            for (var _e = tslib_1.__values(configFileContent.directories), _f = _e.next(); !_f.done; _f = _e.next()) {
                var dirPath = _f.value;
                dirPath = fileSystem.getStandardizedAbsolutePath(dirPath);
                if (dirInProject(dirPath) && fileSystem.directoryExistsSync(dirPath))
                    directories.add(dirPath);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _g = tslib_1.__values(configFileContent.fileNames), _h = _g.next(); !_h.done; _h = _g.next()) {
                var filePath = _h.value;
                filePath = fileSystem.getStandardizedAbsolutePath(filePath);
                var parentDirPath = utils_1.FileUtils.getDirPath(filePath);
                if (dirInProject(parentDirPath) && fileSystem.fileExistsSync(filePath)) {
                    files.add(filePath);
                    directories.add(parentDirPath);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var rootDirs_1 = tslib_1.__values(rootDirs), rootDirs_1_1 = rootDirs_1.next(); !rootDirs_1_1.done; rootDirs_1_1 = rootDirs_1.next()) {
                var rootDir = rootDirs_1_1.value;
                directories.add(rootDir);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (rootDirs_1_1 && !rootDirs_1_1.done && (_c = rootDirs_1.return)) _c.call(rootDirs_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return {
            filePaths: utils_1.ArrayUtils.from(files.values()),
            directoryPaths: utils_1.ArrayUtils.from(directories.values())
        };
        function dirInProject(dirPath) {
            // fast check
            if (directories.has(dirPath))
                return true;
            // otherwise, check the strings
            if (rootDirs.length > 0)
                return rootDirs.some(function (rootDir) { return utils_1.FileUtils.pathStartsWith(dirPath, rootDir); });
            return utils_1.FileUtils.pathStartsWith(dirPath, tsConfigDirPath);
        }
        function getRootDirs(options) {
            var result = [];
            if (typeof options.rootDir === "string")
                result.push(options.rootDir);
            if (options.rootDirs != null)
                result.push.apply(result, tslib_1.__spread(options.rootDirs));
            return result.map(function (rootDir) { return fileSystem.getStandardizedAbsolutePath(rootDir, tsConfigDirPath); });
        }
    };
    TsConfigResolver.prototype.parseJsonConfigFileContent = function () {
        this.host.clearDirectories();
        var result = typescript_1.ts.parseJsonConfigFileContent(this.getTsConfigFileJson(), this.host, this.tsConfigDirPath, undefined, this.tsConfigFilePath);
        delete result.options.configFilePath;
        return tslib_1.__assign({}, result, { directories: this.host.getDirectories() });
    };
    TsConfigResolver.prototype.getTsConfigFileJson = function () {
        var text = this.fileSystem.readFileSync(this.tsConfigFilePath, this.encoding);
        var parseResult = typescript_1.ts.parseConfigFileTextToJson(this.tsConfigFilePath, text);
        if (parseResult.error != null)
            throw new Error(parseResult.error.messageText.toString());
        return parseResult.config;
    };
    tslib_1.__decorate([
        utils_1.Memoize
    ], TsConfigResolver.prototype, "getCompilerOptions", null);
    tslib_1.__decorate([
        utils_1.Memoize
    ], TsConfigResolver.prototype, "getErrors", null);
    tslib_1.__decorate([
        utils_1.Memoize
    ], TsConfigResolver.prototype, "getPaths", null);
    tslib_1.__decorate([
        utils_1.Memoize
    ], TsConfigResolver.prototype, "parseJsonConfigFileContent", null);
    tslib_1.__decorate([
        utils_1.Memoize
    ], TsConfigResolver.prototype, "getTsConfigFileJson", null);
    return TsConfigResolver;
}());
exports.TsConfigResolver = TsConfigResolver;
