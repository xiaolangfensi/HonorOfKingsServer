"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var typescript_1 = require("../../typescript");
var tsInternal = require("../../typescript/tsInternal");
var results_1 = require("./results");
var TypeChecker_1 = require("./TypeChecker");
/**
 * Wrapper around Program.
 */
var Program = /** @class */ (function () {
    /** @private */
    function Program(context, rootNames, host) {
        this._context = context;
        this._typeChecker = new TypeChecker_1.TypeChecker(this._context);
        this._reset(rootNames, host);
    }
    Object.defineProperty(Program.prototype, "compilerObject", {
        /**
         * Gets the underlying compiler program.
         */
        get: function () {
            return this._getOrCreateCompilerObject();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets if the internal compiler program is created.
     * @internal
     */
    Program.prototype._isCompilerProgramCreated = function () {
        return this._createdCompilerObject != null;
    };
    /**
     * Resets the program.
     * @internal
     */
    Program.prototype._reset = function (rootNames, host) {
        var _this = this;
        var compilerOptions = this._context.compilerOptions.get();
        this._getOrCreateCompilerObject = function () {
            // need to use ts.createProgram instead of languageService.getProgram() because the
            // program created by the language service is not fully featured (ex. does not write to the file system)
            if (_this._createdCompilerObject == null) {
                _this._createdCompilerObject = typescript_1.ts.createProgram(rootNames, compilerOptions, host, _this._oldProgram);
                delete _this._oldProgram;
            }
            return _this._createdCompilerObject;
        };
        if (this._createdCompilerObject != null) {
            this._oldProgram = this._createdCompilerObject;
            delete this._createdCompilerObject;
        }
        this._typeChecker._reset(function () { return _this.compilerObject.getTypeChecker(); });
    };
    /**
     * Get the program's type checker.
     */
    Program.prototype.getTypeChecker = function () {
        return this._typeChecker;
    };
    /**
     * Emits the TypeScript files to JavaScript files.
     * @param options - Options for emitting.
     */
    Program.prototype.emit = function (options) {
        if (options === void 0) { options = {}; }
        return new results_1.EmitResult(this._context, this._emit(options));
    };
    /**
     * Emits the TypeScript files to JavaScript files to memory.
     * @param options - Options for emitting.
     */
    Program.prototype.emitToMemory = function (options) {
        if (options === void 0) { options = {}; }
        var sourceFiles = [];
        var fileSystemWrapper = this._context.fileSystemWrapper;
        var emitResult = this._emit(tslib_1.__assign({ writeFile: function (filePath, text, writeByteOrderMark) {
                sourceFiles.push({
                    filePath: fileSystemWrapper.getStandardizedAbsolutePath(filePath),
                    text: text,
                    writeByteOrderMark: writeByteOrderMark || false
                });
            } }, options));
        return new results_1.MemoryEmitResult(this._context, emitResult, sourceFiles);
    };
    /** @internal */
    Program.prototype._emit = function (options) {
        if (options === void 0) { options = {}; }
        var targetSourceFile = options.targetSourceFile != null ? options.targetSourceFile.compilerNode : undefined;
        var emitOnlyDtsFiles = options.emitOnlyDtsFiles, customTransformers = options.customTransformers, writeFile = options.writeFile;
        var cancellationToken = undefined; // todo: expose this
        return this.compilerObject.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
    };
    /**
     * Gets the syntactic diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    Program.prototype.getSyntacticDiagnostics = function (sourceFile) {
        var _this = this;
        var compilerDiagnostics = this.compilerObject.getSyntacticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(function (d) { return _this._context.compilerFactory.getDiagnosticWithLocation(d); });
    };
    /**
     * Gets the semantic diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    Program.prototype.getSemanticDiagnostics = function (sourceFile) {
        var _this = this;
        var compilerDiagnostics = this.compilerObject.getSemanticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(function (d) { return _this._context.compilerFactory.getDiagnostic(d); });
    };
    /**
     * Gets the declaration diagnostics.
     * @param sourceFile - Optional source file to filter by.
     */
    Program.prototype.getDeclarationDiagnostics = function (sourceFile) {
        var _this = this;
        var compilerDiagnostics = this.compilerObject.getDeclarationDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(function (d) { return _this._context.compilerFactory.getDiagnosticWithLocation(d); });
    };
    /**
     * Gets the global diagnostics.
     */
    Program.prototype.getGlobalDiagnostics = function () {
        var _this = this;
        var compilerDiagnostics = this.compilerObject.getGlobalDiagnostics();
        return compilerDiagnostics.map(function (d) { return _this._context.compilerFactory.getDiagnostic(d); });
    };
    /**
     * Gets the emit module resolution kind.
     */
    Program.prototype.getEmitModuleResolutionKind = function () {
        return tsInternal.getEmitModuleResolutionKind(this.compilerObject.getCompilerOptions());
    };
    /**
     * Gets if the provided source file was discovered while loading an external library.
     * @param sourceFile - Source file.
     */
    Program.prototype.isSourceFileFromExternalLibrary = function (sourceFile) {
        // Do not use compilerObject.isSourceFileFromExternalLibrary because that method
        // will become out of date after a manipulation has happened to a source file.
        // Read more in sourceFile.isFromExternalLibrary()'s method body.
        return sourceFile.isFromExternalLibrary();
    };
    return Program;
}());
exports.Program = Program;
