"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var manipulation_1 = require("../../../manipulation");
var getStructureFuncs = require("../../../manipulation/helpers/getStructureFunctions");
var typescript_1 = require("../../../typescript");
var base_1 = require("../base");
var callBaseSet_1 = require("../callBaseSet");
var common_1 = require("../common");
var module_1 = require("../module");
var statement_1 = require("../statement");
var FunctionLikeDeclaration_1 = require("./FunctionLikeDeclaration");
var OverloadableNode_1 = require("./OverloadableNode");
var callBaseGetStructure_1 = require("../callBaseGetStructure");
exports.FunctionDeclarationBase = base_1.ChildOrderableNode(base_1.UnwrappableNode(base_1.TextInsertableNode(OverloadableNode_1.OverloadableNode(base_1.BodyableNode(base_1.AsyncableNode(base_1.GeneratorableNode(FunctionLikeDeclaration_1.FunctionLikeDeclaration(statement_1.StatementedNode(base_1.AmbientableNode(module_1.NamespaceChildableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NameableNode(common_1.Node))))))))))))));
exports.FunctionDeclarationOverloadBase = base_1.ChildOrderableNode(base_1.UnwrappableNode(base_1.TextInsertableNode(base_1.AsyncableNode(base_1.GeneratorableNode(base_1.ModifierableNode(base_1.SignaturedDeclaration(statement_1.StatementedNode(base_1.AmbientableNode(module_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.TypeParameteredNode(base_1.ExportableNode(base_1.ModifierableNode(common_1.Node))))))))))))));
var FunctionDeclaration = /** @class */ (function (_super) {
    tslib_1.__extends(FunctionDeclaration, _super);
    function FunctionDeclaration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Adds a function overload.
     * @param structure - Structure of the overload.
     */
    FunctionDeclaration.prototype.addOverload = function (structure) {
        return this.addOverloads([structure])[0];
    };
    /**
     * Adds function overloads.
     * @param structures - Structures of the overloads.
     */
    FunctionDeclaration.prototype.addOverloads = function (structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    };
    /**
     * Inserts a function overload.
     * @param index - Child index to insert at.
     * @param structure - Structure of the overload.
     */
    FunctionDeclaration.prototype.insertOverload = function (index, structure) {
        return this.insertOverloads(index, [structure])[0];
    };
    /**
     * Inserts function overloads.
     * @param index - Child index to insert at.
     * @param structure - Structures of the overloads.
     */
    FunctionDeclaration.prototype.insertOverloads = function (index, structures) {
        var thisName = this.getName();
        var childCodes = structures.map(function (structure) { return "function " + thisName + "();"; });
        return OverloadableNode_1.insertOverloads({
            node: this,
            index: index,
            structures: structures,
            childCodes: childCodes,
            getThisStructure: getStructureFuncs.fromFunctionDeclarationOverload,
            setNodeFromStructure: function (node, structure) { return node.set(structure); },
            expectedSyntaxKind: typescript_1.SyntaxKind.FunctionDeclaration
        });
    };
    /**
     * Removes this function declaration.
     */
    FunctionDeclaration.prototype.remove = function () {
        manipulation_1.removeOverloadableStatementedNodeChild(this);
    };
    /**
     * Sets the node from a structure.
     * @param structure - Structure to set the node with.
     */
    FunctionDeclaration.prototype.set = function (structure) {
        callBaseSet_1.callBaseSet(exports.FunctionDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(function (o) { return o.remove(); });
            this.addOverloads(structure.overloads);
        }
        return this;
    };
    /**
     * Gets the structure equivalent to this node.
     */
    FunctionDeclaration.prototype.getStructure = function () {
        var isOverload = this.isOverload();
        var hasImplementation = this.getImplementation();
        var basePrototype = isOverload && hasImplementation ? exports.FunctionDeclarationOverloadBase.prototype : exports.FunctionDeclarationBase.prototype;
        var structure = !hasImplementation || isOverload ? {} : { overloads: this.getOverloads().map(function (o) { return o.getStructure(); }) };
        return callBaseGetStructure_1.callBaseGetStructure(basePrototype, this, structure);
    };
    return FunctionDeclaration;
}(exports.FunctionDeclarationBase));
exports.FunctionDeclaration = FunctionDeclaration;
